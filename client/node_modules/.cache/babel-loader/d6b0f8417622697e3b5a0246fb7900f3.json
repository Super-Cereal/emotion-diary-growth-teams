{"ast":null,"code":"function e(e, t) {\n  for (let r in e) t(e[r], r);\n}\n\nfunction t(e, t) {\n  e.forEach(t);\n}\n\nfunction r(e, t) {\n  if (!e) throw Error(t);\n}\n\nfunction n(e, t) {\n  de = {\n    parent: de,\n    value: e,\n    template: oe(e, 'template') || pe(),\n    sidRoot: oe(e, 'sidRoot') || de && de.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    de = ne(de);\n  }\n}\n\nfunction a() {\n  let {\n    node: e = [],\n    from: r,\n    source: n,\n    parent: a = r || n,\n    to: o,\n    target: i,\n    child: l = o || i,\n    scope: s = {},\n    meta: f = {},\n    family: u = {\n      type: 'regular'\n    },\n    regional: c\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let d = ye(a),\n      p = ye(u.links),\n      m = ye(u.owners),\n      g = [];\n  t(e, e => e && K(g, e));\n  let h = {\n    id: ce(),\n    seq: g,\n    next: ye(l),\n    meta: f,\n    scope: s,\n    family: {\n      type: u.type || \"crosslink\",\n      links: p,\n      owners: m\n    }\n  };\n  return t(p, e => K(Y(e), h)), t(m, e => K(Z(e), h)), t(d, e => K(e.next, h)), c && de && he(te(de), [h]), h;\n}\n\nfunction o(e, r, n) {\n  let a = Ze,\n      o = null,\n      i = Ke;\n  if (e.target && (r = e.params, n = e.defer, a = 'page' in e ? e.page : a, e.stack && (o = e.stack), i = ae(e) || i, e = e.target), i && Ke && i !== Ke && (Ke = null), Array.isArray(e)) for (let t = 0; t < e.length; t++) He('pure', a, X(e[t]), o, r[t], i);else He('pure', a, X(e), o, r, i);\n  if (n && !Qe) return;\n  let l,\n      s,\n      f,\n      u,\n      c,\n      d,\n      p = {\n    isRoot: Qe,\n    currentPage: Ze,\n    scope: Ke,\n    isWatch: Xe,\n    isPure: Ye\n  };\n  Qe = 0;\n\n  e: for (; u = We();) {\n    let {\n      idx: e,\n      stack: r,\n      type: n\n    } = u;\n    f = r.node, Ze = c = r.page, Ke = ae(r), c ? d = c.reg : Ke && (d = Ke.reg);\n    let a = !!c,\n        o = !!Ke,\n        i = {\n      fail: 0,\n      scope: f.scope\n    };\n    l = s = 0;\n\n    for (let t = e; t < f.seq.length && !l; t++) {\n      let u = f.seq[t];\n\n      if (u.order) {\n        let {\n          priority: a,\n          barrierID: o\n        } = u.order,\n            i = o ? c ? `${c.fullID}_${o}` : o : 0;\n\n        if (t !== e || n !== a) {\n          o ? Je.has(i) || (Je.add(i), Ue(t, r, a, o)) : Ue(t, r, a);\n          continue e;\n        }\n\n        o && Je.delete(i);\n      }\n\n      switch (u.type) {\n        case 'mov':\n          {\n            let e,\n                t = u.data;\n\n            switch (t.from) {\n              case _:\n                e = te(r);\n                break;\n\n              case \"a\":\n              case 'b':\n                e = r[t.from];\n                break;\n\n              case \"value\":\n                e = t.store;\n                break;\n\n              case \"store\":\n                if (d && !d[t.store.id]) if (a) {\n                  let e = rt(c, t.store.id);\n                  r.page = c = e, e ? d = e.reg : o ? (at(Ke, t.store, 0, 1, t.softRead), d = Ke.reg) : d = void 0;\n                } else o && at(Ke, t.store, 0, 1, t.softRead);\n                e = _e(d && d[t.store.id] || t.store);\n            }\n\n            switch (t.to) {\n              case _:\n                r.value = e;\n                break;\n\n              case \"a\":\n              case 'b':\n                r[t.to] = e;\n                break;\n\n              case \"store\":\n                nt(c, Ke, f, t.target).current = e;\n            }\n\n            break;\n          }\n\n        case 'compute':\n          let e = u.data;\n\n          if (e.fn) {\n            Xe = 'watch' === oe(f, 'op'), Ye = e.pure;\n            let t = e.safe ? (0, e.fn)(te(r), i.scope, r) : ot(i, e.fn, r);\n            e.filter ? s = !t : r.value = t, Xe = p.isWatch, Ye = p.isPure;\n          }\n\n      }\n\n      l = i.fail || s;\n    }\n\n    if (!l) {\n      let e = te(r);\n      t(f.next, t => {\n        He('child', c, t, r, e, ae(r));\n      });\n      let n = ae(r);\n\n      if (n) {\n        oe(f, 'needFxCounter') && He('child', c, n.fxCount, r, e, n), oe(f, 'storeChange') && He('child', c, n.storeChange, r, e, n), oe(f, 'warnSerialize') && He('child', c, n.warnSerializeNode, r, e, n);\n        let a = n.additionalLinks[f.id];\n        a && t(a, t => {\n          He('child', c, t, r, e, n);\n        });\n      }\n    }\n  }\n\n  Qe = p.isRoot, Ze = p.currentPage, Ke = ae(p);\n}\n\nfunction i(t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"combine\";\n  let n = r + '(',\n      a = '',\n      o = 0;\n  return e(t, e => {\n    o < 25 && (null != e && (n += a, n += E(e) ? le(e).fullName : e.toString()), o += 1, a = ', ');\n  }), n + ')';\n}\n\nfunction l(e, t) {\n  e.shortName = t, Object.assign(le(e), s(t, ne(e)));\n}\n\nfunction s(e, t) {\n  let r,\n      n,\n      a = e;\n\n  if (t) {\n    let a = le(t);\n    0 === e.length ? (r = a.path, n = a.fullName) : (r = a.path.concat([e]), n = 0 === a.fullName.length ? e : a.fullName + '/' + e);\n  } else r = 0 === e.length ? [] : [e], n = e;\n\n  return {\n    shortName: a,\n    fullName: n,\n    path: r\n  };\n}\n\nfunction f(e, t) {\n  let r = t ? e : e[0];\n  we(r);\n  let n = r.or,\n      a = r.and;\n\n  if (a) {\n    let r = t ? a : a[0];\n\n    if (be(r) && 'and' in r) {\n      let r = f(a, t);\n      e = r[0], n = { ...n,\n        ...r[1]\n      };\n    } else e = a;\n  }\n\n  return [e, n];\n}\n\nfunction u(e) {\n  let r = pe();\n\n  if (r) {\n    let n = r.handlers[e];\n\n    for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      t[_key - 1] = arguments[_key];\n    }\n\n    if (n) return n(r, ...t);\n  }\n}\n\nfunction c(e, t) {\n  let r = function (e) {\n    for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      t[_key2 - 1] = arguments[_key2];\n    }\n\n    return Q(!oe(r, 'derived'), 'call of derived event', 'createEvent'), Q(!Ye, 'unit call from pure function', 'operators like sample'), Ze ? ((e, t, r, n) => {\n      let a = Ze,\n          o = null;\n      if (t) for (o = Ze; o && o.template !== t;) o = ne(o);\n      tt(o);\n      let i = e.create(r, n);\n      return tt(a), i;\n    })(r, n, e, t) : r.create(e, t);\n  },\n      n = pe();\n\n  return Object.assign(r, {\n    graphite: a({\n      meta: yt(\"event\", r, e, t),\n      regional: 1\n    }),\n    create: e => (o({\n      target: r,\n      params: e,\n      scope: Ke\n    }), e),\n    watch: e => gt(r, e),\n    map: e => bt(r, P, e, [De()]),\n    filter: e => bt(r, \"filter\", e.fn ? e : e.fn, [De(Me, 1)]),\n    filterMap: e => bt(r, 'filterMap', e, [De(), Oe(e => !ke(e), 1)]),\n\n    prepend(e) {\n      let t = c('* \\u2192 ' + r.shortName, {\n        parent: ne(r)\n      });\n      return u('eventPrepend', X(t)), pt(t, r, [De()], 'prepend', e), ht(r, t), t;\n    }\n\n  });\n}\n\nfunction d(e, n) {\n  let i = Pe(e),\n      l = c({\n    named: 'updates',\n    derived: 1\n  });\n  u('storeBase', i);\n  let s = i.id,\n      f = {\n    subscribers: new Map(),\n    updates: l,\n    defaultState: e,\n    stateRef: i,\n\n    getState() {\n      let e,\n          t = i;\n\n      if (Ze) {\n        let t = Ze;\n\n        for (; t && !t.reg[s];) t = ne(t);\n\n        t && (e = t);\n      }\n\n      return !e && Ke && (at(Ke, i, 1), e = Ke), e && (t = e.reg[s]), _e(t);\n    },\n\n    setState: e => o({\n      target: f,\n      params: e,\n      defer: 1,\n      scope: Ke\n    }),\n    reset: function () {\n      for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        e[_key3] = arguments[_key3];\n      }\n\n      return t(e, e => f.on(e, () => f.defaultState)), f;\n    },\n    on: (e, r) => (xe(e, '.on', 'first argument'), Q(!oe(f, 'derived'), '.on in derived store', 'createStore'), t(Array.isArray(e) ? e : [e], e => {\n      f.off(e), re(f).set(e, dt(vt(e, f, 'on', je, r)));\n    }), f),\n\n    off(e) {\n      let t = re(f).get(e);\n      return t && (t(), re(f).delete(e)), f;\n    },\n\n    map(e, t) {\n      let r, n;\n      be(e) && (r = e, e = e.fn), Q(ke(t), 'second argument of store.map', 'updateFilter');\n      let a = f.getState();\n      pe() ? n = null : ke(a) || (n = e(a, t));\n      let o = d(n, {\n        name: `${f.shortName} \\u2192 *`,\n        derived: 1,\n        and: r\n      }),\n          l = vt(f, o, P, $e, e);\n      return Ee(ee(o), {\n        type: P,\n        fn: e,\n        from: i\n      }), ee(o).noInit = 1, u('storeMap', i, l), o;\n    },\n\n    watch(e, t) {\n      if (!t || !E(e)) {\n        let t = gt(f, e);\n        return u('storeWatch', i, e) || e(f.getState()), t;\n      }\n\n      return r(ve(t), 'second argument should be a function'), e.watch(e => t(f.getState(), e));\n    }\n\n  },\n      p = yt(\"store\", f, n),\n      m = f.defaultConfig.updateFilter;\n  f.graphite = a({\n    scope: {\n      state: i,\n      fn: m\n    },\n    node: [Oe((e, t, r) => (r.scope && !r.scope.reg[i.id] && (r.b = 1), e)), Fe(i), Oe((e, t, _ref) => {\n      let {\n        a: r,\n        b: n\n      } = _ref;\n      return !ke(e) && (e !== r || n);\n    }, 1), m && De($e, 1), qe({\n      from: _,\n      target: i\n    })],\n    child: l,\n    meta: p,\n    regional: 1\n  });\n  let g = oe(f, 'derived'),\n      h = 'ignore' === oe(f, 'serialize'),\n      y = oe(f, 'sid');\n  return y && (h || ie(f, 'storeChange', 1), i.sid = y), y || h || g || ie(f, 'warnSerialize', 1), r(g || !ke(e), \"current state can't be undefined, use null instead\"), he(f, [l]), f;\n}\n\nfunction p() {\n  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    e[_key4] = arguments[_key4];\n  }\n\n  let t, n, a;\n  [e, a] = f(e);\n  let o,\n      i,\n      l,\n      s = e[e.length - 1];\n\n  if (ve(s) ? (n = e.slice(0, -1), t = s) : n = e, 1 === n.length) {\n    let e = n[0];\n    L(e) || (o = e, i = 1);\n  }\n\n  if (!i && (o = n, t)) {\n    l = 1;\n    let e = t;\n\n    t = t => e(...t);\n  }\n\n  return r(be(o), 'shape should be an object'), kt(Array.isArray(o), !l, o, a, t);\n}\n\nfunction m() {\n  return Q(0, 'createStoreObject', 'combine'), p(...arguments);\n}\n\nfunction g() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\n\nfunction h(e, t) {\n  let n = c(ve(e) ? {\n    handler: e\n  } : e, t),\n      i = X(n);\n  ie(i, 'op', n.kind = \"effect\"), n.use = e => (r(ve(e), '.use argument should be a function'), m.scope.handler = e, n), n.use.getCurrent = () => m.scope.handler;\n  let l = n.finally = c({\n    named: 'finally',\n    derived: 1\n  }),\n      s = n.done = l.filterMap({\n    named: 'done',\n\n    fn(_ref2) {\n      let {\n        status: e,\n        params: t,\n        result: r\n      } = _ref2;\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n\n  }),\n      f = n.fail = l.filterMap({\n    named: 'fail',\n\n    fn(_ref3) {\n      let {\n        status: e,\n        params: t,\n        error: r\n      } = _ref3;\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n\n  }),\n      u = n.doneData = s.map({\n    named: 'doneData',\n    fn: _ref4 => {\n      let {\n        result: e\n      } = _ref4;\n      return e;\n    }\n  }),\n      p = n.failData = f.map({\n    named: 'failData',\n    fn: _ref5 => {\n      let {\n        error: e\n      } = _ref5;\n      return e;\n    }\n  }),\n      m = a({\n    scope: {\n      handlerId: oe(i, 'sid'),\n      handler: n.defaultConfig.handler || (() => r(0, `no handler used in ${n.getType()}`))\n    },\n    node: [Oe((e, t, r) => {\n      let n = t,\n          a = n.handler;\n\n      if (ae(r)) {\n        let e = ae(r).handlers[n.handlerId];\n        e && (a = e);\n      }\n\n      return e.handler = a, e;\n    }, 0, 1), Oe((_ref6, a, o) => {\n      let {\n        params: e,\n        req: t,\n        handler: r,\n        args: n = [e]\n      } = _ref6;\n      let i = St(e, t, 1, l, o),\n          s = St(e, t, 0, l, o),\n          [f, u] = wt(r, s, n);\n      f && (be(u) && ve(u.then) ? u.then(i, s) : i(u));\n    }, 0, 1)],\n    meta: {\n      op: 'fx',\n      fx: 'runner'\n    }\n  });\n  i.scope.runner = m, K(i.seq, Oe((e, _ref7, r) => {\n    let {\n      runner: t\n    } = _ref7;\n    let n = ne(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n\n        rj(e) {}\n\n      }\n    } : e;\n    return o({\n      target: t,\n      params: n,\n      defer: 1,\n      scope: ae(r)\n    }), n.params;\n  }, 0, 1)), n.create = e => {\n    let t = g(),\n        r = {\n      params: e,\n      req: t\n    };\n\n    if (Ke) {\n      if (!Xe) {\n        let e = Ke;\n        t.req.finally(() => {\n          et(e);\n        }).catch(() => {});\n      }\n\n      o({\n        target: n,\n        params: r,\n        scope: Ke\n      });\n    } else o(n, r);\n\n    return t.req;\n  };\n  let h = n.inFlight = d(0, {\n    serialize: 'ignore'\n  }).on(n, e => e + 1).on(l, e => e - 1).map({\n    fn: e => e,\n    named: 'inFlight'\n  });\n  ie(l, 'needFxCounter', 'dec'), ie(n, 'needFxCounter', 1);\n  let y = n.pending = h.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return he(n, [l, s, f, u, p, y, h]), n;\n}\n\nfunction y(e) {\n  let t;\n  [e, t] = f(e, 1);\n  let {\n    source: r,\n    effect: n,\n    mapParams: a\n  } = e,\n      i = h(e, t);\n  ie(i, 'attached', 1);\n  let l,\n      {\n    runner: u\n  } = X(i).scope,\n      c = Oe((e, t, n) => {\n    let l,\n        {\n      params: s,\n      req: f,\n      handler: u\n    } = e,\n        c = i.finally,\n        d = St(s, f, 0, c, n),\n        p = n.a,\n        m = B(u),\n        g = 1;\n\n    if (a ? [g, l] = wt(a, d, [s, p]) : l = r && m ? p : s, g) {\n      if (!m) return e.args = [p, l], 1;\n      o({\n        target: u,\n        params: {\n          params: l,\n          req: {\n            rs: St(s, f, 1, c, n),\n            rj: d\n          }\n        },\n        page: n.page,\n        defer: 1\n      });\n    }\n  }, 1, 1);\n\n  if (r) {\n    let e;\n    L(r) ? (e = r, he(e, [i])) : (e = p(r), he(i, [e])), l = [Fe(ee(e)), c];\n  } else l = [c];\n\n  u.seq.splice(1, 0, ...l), i.use(n);\n  let d = ne(n);\n  return d && (Object.assign(le(i), s(i.shortName, d)), i.defaultConfig.parent = d), ht(n, i, \"effect\"), i;\n}\n\nfunction b() {\n  for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    t[_key5] = arguments[_key5];\n  }\n\n  let [[r, n], a] = f(t),\n      o = {};\n  return e(n, (e, t) => {\n    let n = o[t] = c(t, {\n      parent: ne(r),\n      config: a\n    });\n    r.on(n, e), ht(r, n);\n  }), o;\n}\n\nfunction v(r, n) {\n  let i = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      l = {\n    history: {},\n    graphite: i,\n    hooks: {}\n  };\n  i.meta = yt(\"domain\", l, r, n), e({\n    Event: c,\n    Effect: h,\n    Store: d,\n    Domain: v\n  }, (e, r) => {\n    let n = r.toLowerCase(),\n        a = c({\n      named: `on${r}`\n    });\n    l.hooks[n] = a;\n    let i = new Set();\n    l.history[`${n}s`] = i, a.create = e => (o(a, e), e), K(X(a).seq, Oe((e, t, r) => (r.scope = null, e))), a.watch(e => {\n      he(l, [e]), i.add(e), e.ownerSet || (e.ownerSet = i), ne(e) || (e.parent = l);\n    }), he(l, [a]), l[`onCreate${r}`] = e => (t(i, e), a.watch(e)), l[`create${r}`] = l[n] = (t, r) => a(e(t, {\n      parent: l,\n      or: r\n    }));\n  });\n  let s = ne(l);\n  return s && e(l.hooks, (e, t) => pt(e, s.hooks[t])), l;\n}\n\nfunction k(e) {\n  we(e);\n  let t = R in e ? e[R]() : e;\n  r(t.subscribe, 'expect observable to have .subscribe');\n  let n = c(),\n      a = dt(n);\n  return t.subscribe({\n    next: n,\n    error: a,\n    complete: a\n  }), n;\n}\n\nfunction w(e, t) {\n  xe(e, 'merge', 'first argument');\n  let r = c({\n    name: i(e, 'merge'),\n    derived: 1,\n    and: t\n  });\n  return pt(e, r, [], 'merge'), r;\n}\n\nfunction S(e, n) {\n  let a = 0;\n  return t(Ct, t => {\n    t in e && (r(null != e[t], $t(n, t)), a = 1);\n  }), a;\n}\n\nfunction x() {\n  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    e[_key6] = arguments[_key6];\n  }\n\n  let t,\n      r,\n      n,\n      a,\n      [[o, i, l], s] = f(e),\n      u = 1;\n  return ke(i) && be(o) && S(o, \"sample\") && (i = o.clock, l = o.fn, u = !o.greedy, a = o.filter, t = o.target, r = o.name, n = o.sid, o = o.source), jt(\"sample\", i, o, a, t, l, r, s, u, 1, 0, n);\n}\n\nfunction C() {\n  for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    e[_key7] = arguments[_key7];\n  }\n\n  let [[t, r], n] = f(e);\n  return r || (r = t, t = r.source), S(r, 'guard'), jt('guard', r.clock, t, r.filter, r.target, null, r.name, n, !r.greedy, 0, 1);\n}\n\nfunction $(t, r, n) {\n  if (L(t)) return Q(0, 'restore($store)'), t;\n\n  if (T(t) || B(t)) {\n    let e = ne(t),\n        a = d(r, {\n      parent: e,\n      name: t.shortName,\n      and: n\n    });\n    return pt(B(t) ? t.doneData : t, a), e && e.hooks.store(a), a;\n  }\n\n  let a = Array.isArray(t) ? [] : {};\n  return e(t, (e, t) => a[t] = L(e) ? e : d(e, {\n    name: t\n  })), a;\n}\n\nfunction j() {\n  for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    t[_key8] = arguments[_key8];\n  }\n\n  let n,\n      o,\n      i = 'split',\n      [[l, s], d] = f(t),\n      p = !s;\n  p && (n = l.cases, s = l.match, o = l.clock, l = l.source);\n  let m = L(s),\n      g = !E(s) && ve(s),\n      h = !m && !g && be(s);\n  n || (n = {}), p ? e(n, (e, t) => Ce(i, e, `cases.${t}`)) : (r(h, 'match should be an object'), e(s, (e, t) => n[t] = c({\n    derived: 1,\n    and: d\n  })), n.__ = c({\n    derived: 1,\n    and: d\n  }));\n  let y,\n      b = new Set([].concat(l, o || [], Object.values(n))),\n      v = Object.keys(m || g ? n : s);\n  if (m || g) m && b.add(s), y = [m && Fe(ee(s), 0, 1), Ne({\n    safe: m,\n    filter: 1,\n    pure: !m,\n\n    fn(e, t, r) {\n      let n = String(m ? r.a : s(e));\n      It(t, G(v, n) ? n : '__', e, r);\n    }\n\n  })];else if (h) {\n    let t = Pe({});\n    t.type = 'shape';\n    let r,\n        n = [];\n    e(s, (e, a) => {\n      if (E(e)) {\n        r = 1, K(n, a), b.add(e);\n        let o = pt(e, [], [Fe(t), Oe((e, t, _ref8) => {\n          let {\n            a: r\n          } = _ref8;\n          return r[a] = e;\n        })]);\n\n        if (L(e)) {\n          t.current[a] = e.getState();\n          let r = ee(e);\n          Ee(t, {\n            from: r,\n            field: a,\n            type: 'field'\n          }), u('splitMatchStore', r, o);\n        }\n      }\n    }), r && u('splitBase', t), y = [r && Fe(t, 0, 1), De((e, t, r) => {\n      for (let a = 0; a < v.length; a++) {\n        let o = v[a];\n        if (G(n, o) ? r.a[o] : s[o](e)) return void It(t, o, e, r);\n      }\n\n      It(t, '__', e, r);\n    }, 1)];\n  } else r(0, 'expect match to be unit, function or object');\n  let k = a({\n    meta: {\n      op: i\n    },\n    parent: o ? [] : l,\n    scope: n,\n    node: y,\n    family: {\n      owners: Array.from(b)\n    },\n    regional: 1\n  });\n  if (o && jt(i, o, l, null, k, null, i, d, 0, 0, 0), !p) return n;\n}\n\nfunction M(e, _ref9) {\n  let {\n    scope: t,\n    params: r\n  } = _ref9;\n  if (!E(e)) return Promise.reject(new Error('first argument should be unit'));\n  if (!B(e) && !T(e) && !L(e)) return Promise.reject(new Error('first argument accepts only effects, events and stores'));\n  let n = g();\n  n.parentFork = Ke;\n  let {\n    fxCount: a\n  } = t;\n  K(a.scope.defers, n);\n  let i = [e],\n      l = [];\n  return K(l, B(e) ? {\n    params: r,\n    req: {\n      rs(e) {\n        n.value = {\n          status: 'done',\n          value: e\n        };\n      },\n\n      rj(e) {\n        n.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n\n    }\n  } : r), K(i, a), K(l, null), o({\n    target: i,\n    params: l,\n    scope: t\n  }), n.req;\n}\n\nfunction A(e, r) {\n  let n = [];\n\n  (function e(a) {\n    G(n, a) || (K(n, a), \"store\" === oe(a, 'op') && oe(a, 'sid') && r(a, oe(a, 'sid')), t(a.next, e), t(Y(a), e), t(Z(a), e));\n  })(e);\n}\n\nfunction I(e, n) {\n  if (Array.isArray(e) && (e = new Map(e)), e instanceof Map) {\n    let a = {};\n    return t(e, (e, t) => {\n      r(E(t), 'Map key should be a unit'), n && n(t, e), r(t.sid, 'unit should have a sid'), r(!(t.sid in a), 'duplicate sid found'), a[t.sid] = e;\n    }), a;\n  }\n\n  return e;\n}\n\nfunction q(e, n) {\n  let o,\n      i = e;\n  W(e) && (o = e, i = n);\n\n  let l = (e => {\n    let r = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [Oe((e, t, r) => {\n        ne(r) ? 'dec' === oe(ne(r).node, 'needFxCounter') ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n      }), Ne({\n        priority: \"sampler\",\n        batch: 1\n      }), Oe((e, r) => {\n        let {\n          defers: n,\n          fxID: a\n        } = r;\n        r.inFlight > 0 || 0 === n.length || Promise.resolve().then(() => {\n          r.fxID === a && t(n.splice(0, n.length), e => {\n            et(e.parentFork), e.rs(e.value);\n          });\n        });\n      }, 0, 1)]\n    }),\n        n = a({\n      node: [Oe((e, t, r) => {\n        let n = ne(r);\n\n        if (n) {\n          let t = n.node;\n\n          if (!oe(t, 'isCombine') || ne(n) && 'combine' !== oe(ne(n).node, 'op')) {\n            let n = ae(r),\n                a = t.scope.state.id,\n                o = oe(t, 'sid');\n            n.sidIdMap[o] = a, n.sidValuesMap[o] = e;\n          }\n        }\n      })]\n    }),\n        o = a({\n      node: [Oe((e, t, r) => {\n        let n = ae(r);\n\n        if (n) {\n          let e = ne(r);\n          e && (!oe(e.node, 'isCombine') || ne(e) && 'combine' !== oe(ne(e).node, 'op')) && (n.warnSerialize = 1);\n        }\n      })]\n    }),\n        i = {\n      cloneOf: e,\n      reg: {},\n      sidValuesMap: {},\n      sidIdMap: {},\n\n      getState(e) {\n        if ('current' in e) return nt(Ze, i, null, e).current;\n        let t = X(e);\n        return nt(Ze, i, t, t.scope.state, 1).current;\n      },\n\n      kind: \"scope\",\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [r, n, o]\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: r\n        }\n      }),\n      additionalLinks: {},\n      handlers: {},\n      fxCount: r,\n      storeChange: n,\n      warnSerializeNode: o\n    };\n    return i;\n  })(o);\n\n  if (i) {\n    if (i.values) {\n      let e = I(i.values, e => r(L(e), 'Values map can contain only stores as keys'));\n      Object.assign(l.sidValuesMap, e);\n    }\n\n    i.handlers && (l.handlers = I(i.handlers, e => r(B(e), \"Handlers map can contain only effects as keys\")));\n  }\n\n  return l;\n}\n\nfunction N(e, _ref10) {\n  let {\n    values: t\n  } = _ref10;\n  r(be(t), 'values property should be an object');\n  let n,\n      a,\n      i,\n      l = I(t),\n      s = Object.getOwnPropertyNames(l),\n      f = [],\n      u = [];\n  H(e) ? (n = e, i = 1, r(n.cloneOf, 'scope should be created from domain'), a = X(n.cloneOf)) : W(e) ? a = X(e) : r(0, 'first argument of hydrate should be domain or scope'), A(a, (e, t) => {\n    G(s, t) && (K(f, e), K(u, l[t]));\n  }), o({\n    target: f,\n    params: u,\n    scope: n\n  }), i && Object.assign(n.sidValuesMap, l);\n}\n\nfunction z(e) {\n  let {\n    scope: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  r(t || Ke, 'scopeBind cannot be called outside of forked .watch');\n  let n = t || Ke;\n  return B(e) ? t => {\n    let r = g();\n    return o({\n      target: e,\n      params: {\n        params: t,\n        req: r\n      },\n      scope: n\n    }), r.req;\n  } : t => (o({\n    target: e,\n    params: t,\n    scope: n\n  }), t);\n}\n\nfunction O(t) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  t.warnSerialize && console.error('There is a store without sid in this scope, its value is omitted');\n  let a = n.ignore ? n.ignore.map(_ref11 => {\n    let {\n      sid: e\n    } = _ref11;\n    return e;\n  }) : [],\n      o = {};\n  return e(t.sidValuesMap, (e, r) => {\n    if (G(a, r)) return;\n    let n = t.sidIdMap[r];\n    o[r] = n && n in t.reg ? t.reg[n].current : e;\n  }), 'onlyChanges' in n && !n.onlyChanges && (r(t.cloneOf, 'scope should be created from domain'), A(X(t.cloneOf), (e, r) => {\n    r in o || G(a, r) || oe(e, 'isCombine') || 'ignore' === oe(e, 'serialize') || (o[r] = t.getState(e));\n  })), o;\n}\n\nfunction F(_ref12) {\n  let {\n    unit: e,\n    fn: t,\n    scope: r\n  } = _ref12;\n  let n = [Re.run({\n    fn: e => t(e)\n  })];\n\n  if (r) {\n    let t = a({\n      node: n\n    }),\n        o = e.graphite.id,\n        i = r.additionalLinks,\n        l = i[o] || [];\n    return i[o] = l, l.push(t), D(() => {\n      let e = l.indexOf(t);\n      -1 !== e && l.splice(e, 1), ct(t);\n    });\n  }\n\n  {\n    let t = a({\n      node: n,\n      parent: [e],\n      family: {\n        owners: e\n      }\n    });\n    return D(() => {\n      ct(t);\n    });\n  }\n}\n\nfunction D(e) {\n  let t = () => e();\n\n  return t.unsubscribe = () => e(), t;\n}\n\nlet R = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    P = 'map',\n    _ = 'stack',\n    E = e => (ve(e) || be(e)) && 'kind' in e;\n\nconst V = e => t => E(t) && t.kind === e;\n\nlet L = V(\"store\"),\n    T = V(\"event\"),\n    B = V(\"effect\"),\n    W = V(\"domain\"),\n    H = V(\"scope\");\nvar U = {\n  __proto__: null,\n  unit: E,\n  store: L,\n  event: T,\n  effect: B,\n  domain: W,\n  scope: H\n};\n\nlet G = (e, t) => e.includes(t),\n    J = (e, t) => {\n  let r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n},\n    K = (e, t) => e.push(t),\n    Q = (e, t, r) => !e && console.error(`${t} is deprecated${r ? `, use ${r} instead` : ''}`),\n    X = e => e.graphite || e,\n    Y = e => e.family.owners,\n    Z = e => e.family.links,\n    ee = e => e.stateRef,\n    te = e => e.value,\n    re = e => e.subscribers,\n    ne = e => e.parent,\n    ae = e => e.scope,\n    oe = (e, t) => X(e).meta[t],\n    ie = (e, t, r) => X(e).meta[t] = r,\n    le = e => e.compositeName;\n\nconst se = () => {\n  let e = 0;\n  return () => \"\" + ++e;\n};\n\nlet fe = se(),\n    ue = se(),\n    ce = se(),\n    de = null,\n    pe = () => de && de.template,\n    me = e => (e && de && de.sidRoot && (e = `${de.sidRoot}|${e}`), e),\n    ge = _ref13 => {\n  let {\n    sid: e,\n    name: t,\n    loc: r,\n    method: o,\n    fn: i\n  } = _ref13;\n  return n(a({\n    meta: {\n      sidRoot: me(e),\n      name: t,\n      loc: r,\n      method: o\n    }\n  }), i);\n},\n    he = (e, r) => {\n  let n = X(e);\n  t(r, e => {\n    let t = X(e);\n    \"domain\" !== n.family.type && (t.family.type = \"crosslink\"), K(Y(t), n), K(Z(n), t);\n  });\n},\n    ye = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return (Array.isArray(e) ? e : [e]).flat().map(X);\n},\n    be = e => 'object' == typeof e && null !== e,\n    ve = e => 'function' == typeof e,\n    ke = e => void 0 === e,\n    we = e => r(be(e) || ve(e), 'expect first argument be an object');\n\nconst Se = (e, t, n, a) => r(!(!be(e) && !ve(e) || !('family' in e) && !('graphite' in e)), `${t}: expect ${n} to be a unit (store, event or effect)${a}`);\n\nlet xe = (e, r, n) => {\n  Array.isArray(e) ? t(e, (e, t) => Se(e, r, `${t} item of ${n}`, '')) : Se(e, r, n, ' or array of units');\n},\n    Ce = function (e, r) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"target\";\n  return t(ye(r), t => Q(!oe(t, 'derived'), `${e}: derived unit in \"${n}\"`, \"createEvent/createStore\"));\n},\n    $e = (e, _ref14, _ref15) => {\n  let {\n    fn: t\n  } = _ref14;\n  let {\n    a: r\n  } = _ref15;\n  return t(e, r);\n},\n    je = (e, _ref16, _ref17) => {\n  let {\n    fn: t\n  } = _ref16;\n  let {\n    a: r\n  } = _ref17;\n  return t(r, e);\n},\n    Me = (e, _ref18) => {\n  let {\n    fn: t\n  } = _ref18;\n  return t(e);\n};\n\nconst Ae = (e, t, r, n) => {\n  let a = {\n    id: ue(),\n    type: e,\n    data: t\n  };\n  return r && (a.order = {\n    priority: r\n  }, n && (a.order.barrierID = ++Ie)), a;\n};\n\nlet Ie = 0,\n    qe = _ref19 => {\n  let {\n    from: e = \"store\",\n    store: t,\n    target: r,\n    to: n = r ? \"store\" : _,\n    batch: a,\n    priority: o\n  } = _ref19;\n  return Ae('mov', {\n    from: e,\n    store: t,\n    to: n,\n    target: r\n  }, o, a);\n},\n    Ne = _ref20 => {\n  let {\n    fn: e,\n    batch: t,\n    priority: r,\n    safe: n = 0,\n    filter: a = 0,\n    pure: o = 0\n  } = _ref20;\n  return Ae('compute', {\n    fn: e,\n    safe: n,\n    filter: a,\n    pure: o\n  }, r, t);\n},\n    ze = _ref21 => {\n  let {\n    fn: e\n  } = _ref21;\n  return Ne({\n    fn: e,\n    priority: \"effect\"\n  });\n},\n    Oe = (e, t, r) => Ne({\n  fn: e,\n  safe: 1,\n  filter: t,\n  priority: r && \"effect\"\n}),\n    Fe = (e, t, r) => qe({\n  store: e,\n  to: t ? _ : \"a\",\n  priority: r && \"sampler\",\n  batch: 1\n}),\n    De = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Me;\n  let t = arguments.length > 1 ? arguments[1] : undefined;\n  return Ne({\n    fn: e,\n    pure: 1,\n    filter: t\n  });\n},\n    Re = {\n  mov: qe,\n  compute: Ne,\n  filter: _ref22 => {\n    let {\n      fn: e,\n      pure: t\n    } = _ref22;\n    return Ne({\n      fn: e,\n      filter: 1,\n      pure: t\n    });\n  },\n  run: ze\n},\n    Pe = e => ({\n  id: ue(),\n  current: e\n}),\n    _e = _ref23 => {\n  let {\n    current: e\n  } = _ref23;\n  return e;\n},\n    Ee = (e, t) => {\n  e.before || (e.before = []), K(e.before, t);\n},\n    Ve = null;\n\nconst Le = (e, t) => {\n  if (!e) return t;\n  if (!t) return e;\n  let r;\n  return (e.v.type === t.v.type && e.v.id > t.v.id || Ge(e.v.type) > Ge(t.v.type)) && (r = e, e = t, t = r), r = Le(e.r, t), e.r = e.l, e.l = r, e;\n},\n      Te = [];\n\nlet Be = 0;\n\nfor (; Be < 6;) K(Te, {\n  first: null,\n  last: null,\n  size: 0\n}), Be += 1;\n\nconst We = () => {\n  for (let e = 0; e < 6; e++) {\n    let t = Te[e];\n\n    if (t.size > 0) {\n      if (3 === e || 4 === e) {\n        t.size -= 1;\n        let e = Ve.v;\n        return Ve = Le(Ve.l, Ve.r), e;\n      }\n\n      1 === t.size && (t.last = null);\n      let r = t.first;\n      return t.first = r.r, t.size -= 1, r.v;\n    }\n  }\n},\n      He = (e, t, r, n, a, o) => Ue(0, {\n  a: null,\n  b: null,\n  node: r,\n  parent: n,\n  value: a,\n  page: t,\n  scope: o\n}, e),\n      Ue = function (e, t, r) {\n  let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let a = Ge(r),\n      o = Te[a],\n      i = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: n\n    },\n    l: null,\n    r: null\n  };\n  3 === a || 4 === a ? Ve = Le(Ve, i) : (0 === o.size ? o.first = i : o.last.r = i, o.last = i), o.size += 1;\n},\n      Ge = e => {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case 'read':\n      return 2;\n\n    case \"barrier\":\n      return 3;\n\n    case \"sampler\":\n      return 4;\n\n    case \"effect\":\n      return 5;\n\n    default:\n      return -1;\n  }\n},\n      Je = new Set();\n\nlet Ke,\n    Qe = 1,\n    Xe = 0,\n    Ye = 0,\n    Ze = null,\n    et = e => {\n  Ke = e;\n},\n    tt = e => {\n  Ze = e;\n};\n\nconst rt = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = ne(e);\n\n    if (e) return e;\n  }\n\n  return null;\n};\n\nlet nt = (e, t, r, n, a) => {\n  let o = rt(e, n.id);\n  return o ? o.reg[n.id] : t ? (at(t, n, a), t.reg[n.id]) : n;\n},\n    at = (e, r, n, a, o) => {\n  let i = e.reg,\n      l = r.sid;\n  if (i[r.id]) return;\n  let s = {\n    id: r.id,\n    current: r.current\n  };\n  if (l && l in e.sidValuesMap && !(l in e.sidIdMap)) s.current = e.sidValuesMap[l];else if (r.before && !o) {\n    let o = 0,\n        l = n || !r.noInit || a;\n    t(r.before, t => {\n      switch (t.type) {\n        case P:\n          {\n            let r = t.from;\n\n            if (r || t.fn) {\n              r && at(e, r, n, a);\n              let o = r && i[r.id].current;\n              l && (s.current = t.fn ? t.fn(o) : o);\n            }\n\n            break;\n          }\n\n        case 'field':\n          o || (o = 1, s.current = Array.isArray(s.current) ? [...s.current] : { ...s.current\n          }), at(e, t.from, n, a), l && (s.current[t.field] = i[i[t.from.id].id].current);\n      }\n    });\n  }\n  l && (e.sidIdMap[l] = r.id), i[r.id] = s;\n};\n\nconst ot = (e, t, r) => {\n  try {\n    return t(te(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\n\nlet lt = function (t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return be(t) && (lt(t.or, r), e(t, (e, t) => {\n    ke(e) || 'or' === t || 'and' === t || (r[t] = e);\n  }), lt(t.and, r)), r;\n};\n\nconst st = (e, t) => {\n  J(e.next, t), J(Y(e), t), J(Z(e), t);\n},\n      ft = (e, t, r) => {\n  let n;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  let a = Z(e);\n\n  for (; n = a.pop();) st(n, e), (t || r && 'sample' !== oe(e, 'op') || \"crosslink\" === n.family.type) && ft(n, t, 'on' !== oe(n, 'op') && r);\n\n  for (a = Y(e); n = a.pop();) st(n, e), r && \"crosslink\" === n.family.type && ft(n, t, 'on' !== oe(n, 'op') && r);\n},\n      ut = e => e.clear();\n\nlet ct = function (e) {\n  let {\n    deep: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), L(e)) ut(re(e));else if (W(e)) {\n    r = 1;\n    let t = e.history;\n    ut(t.events), ut(t.effects), ut(t.stores), ut(t.domains);\n  }\n  ft(X(e), !!t, r);\n},\n    dt = e => {\n  let t = () => ct(e);\n\n  return t.unsubscribe = t, t;\n},\n    pt = (e, t, r, n, o) => a({\n  node: r,\n  parent: e,\n  child: t,\n  scope: {\n    fn: o\n  },\n  meta: {\n    op: n\n  },\n  family: {\n    owners: [e, t],\n    links: t\n  },\n  regional: 1\n}),\n    mt = e => {\n  let t = 'forward',\n      [{\n    from: r,\n    to: n\n  }, o] = f(e, 1);\n  return xe(r, t, '\"from\"'), xe(n, t, '\"to\"'), Ce(t, n, 'to'), dt(a({\n    parent: r,\n    child: n,\n    meta: {\n      op: t,\n      config: o\n    },\n    family: {},\n    regional: 1\n  }));\n},\n    gt = (e, t) => (r(ve(t), '.watch argument should be a function'), dt(a({\n  scope: {\n    fn: t\n  },\n  node: [ze({\n    fn: Me\n  })],\n  parent: e,\n  meta: {\n    op: 'watch'\n  },\n  family: {\n    owners: e\n  },\n  regional: 1\n}))),\n    ht = function (e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"event\";\n  ne(e) && ne(e).hooks[r](t);\n},\n    yt = (e, t, r, n) => {\n  let a = \"domain\" === e,\n      o = fe(),\n      i = lt({\n    or: n,\n    and: 'string' == typeof r ? {\n      name: r\n    } : r\n  }),\n      {\n    parent: l = null,\n    sid: f = null,\n    named: u = null\n  } = i,\n      c = u || i.name || (a ? '' : o),\n      d = s(c, l),\n      p = {\n    op: t.kind = e,\n    name: t.shortName = c,\n    sid: t.sid = me(f),\n    named: u,\n    unitId: t.id = o,\n    serialize: i.serialize,\n    derived: i.derived,\n    config: i\n  };\n\n  if (t.parent = l, t.compositeName = d, t.defaultConfig = i, t.thru = e => (Q(0, 'thru', 'js pipe'), e(t)), t.getType = () => d.fullName, !a) {\n    t.subscribe = e => (we(e), t.watch(ve(e) ? e : t => e.next && e.next(t))), t[R] = () => t;\n    let e = pe();\n    e && (p.nativeTemplate = e);\n  }\n\n  return p;\n};\n\nconst bt = (e, t, r, n) => {\n  let a;\n  be(r) && (a = r, r = r.fn);\n  let o = c({\n    name: `${e.shortName} \\u2192 *`,\n    derived: 1,\n    and: a\n  });\n  return pt(e, o, n, t, r), o;\n},\n      vt = (e, t, r, n, a) => {\n  let o = ee(t),\n      i = qe({\n    store: o,\n    to: \"a\",\n    priority: 'read'\n  });\n  r === P && (i.data.softRead = 1);\n  let l = [i, De(n)];\n  return u('storeOnMap', o, l, L(e) && ee(e)), pt(e, t, l, r, a);\n},\n      kt = (t, n, a, o, l) => {\n  let s = t ? e => e.slice() : e => ({ ...e\n  }),\n      f = t ? [] : {},\n      c = s(f),\n      p = Pe(c),\n      m = Pe(1);\n  p.type = t ? 'list' : 'shape', p.noInit = 1, u('combineBase', p, m);\n  let g = d(c, {\n    name: i(a),\n    derived: 1,\n    and: o\n  }),\n      h = ee(g);\n  h.noInit = 1, ie(g, 'isCombine', 1);\n  let y = Fe(p);\n  y.order = {\n    priority: 'barrier'\n  };\n  let b = [Oe((e, t, r) => (r.scope && !r.scope.reg[p.id] && (r.c = 1), e)), y, qe({\n    store: m,\n    to: 'b'\n  }), Oe((e, _ref24, r) => {\n    let {\n      key: t\n    } = _ref24;\n    if (r.c || e !== r.a[t]) return n && r.b && (r.a = s(r.a)), r.a[t] = e, 1;\n  }, 1), qe({\n    from: \"a\",\n    target: p\n  }), qe({\n    from: \"value\",\n    store: 0,\n    target: m\n  }), qe({\n    from: \"value\",\n    store: 1,\n    target: m,\n    priority: \"barrier\",\n    batch: 1\n  }), Fe(p, 1), l && De()];\n  return e(a, (e, t) => {\n    if (!L(e)) return r(!E(e) && !ke(e), `combine expects a store in a field ${t}`), void (c[t] = f[t] = e);\n    f[t] = e.defaultState, c[t] = e.getState();\n    let n = pt(e, g, b, 'combine', l);\n    n.scope.key = t;\n    let a = ee(e);\n    Ee(p, {\n      type: 'field',\n      field: t,\n      from: a\n    }), u('combineField', a, n);\n  }), g.defaultShape = a, Ee(h, {\n    type: P,\n    from: p,\n    fn: l\n  }), pe() || (g.defaultState = l ? h.current = l(c) : f), g;\n};\n\nlet wt = (e, t, r) => {\n  try {\n    return [1, e(...r)];\n  } catch (e) {\n    return t(e), [0, null];\n  }\n},\n    St = (e, t, r, n, a) => i => o({\n  target: [n, xt],\n  params: [r ? {\n    status: 'done',\n    params: e,\n    result: i\n  } : {\n    status: 'fail',\n    params: e,\n    error: i\n  }, {\n    value: i,\n    fn: r ? t.rs : t.rj\n  }],\n  defer: 1,\n  page: a.page,\n  scope: ae(a)\n});\n\nconst xt = a({\n  node: [ze({\n    fn: _ref25 => {\n      let {\n        fn: e,\n        value: t\n      } = _ref25;\n      return e(t);\n    }\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n}),\n      Ct = ['source', 'clock', 'target'],\n      $t = (e, t) => e + `: ${t} should be defined`;\n\nlet jt = (e, t, n, a, o, i, l, s, f, m, g, h) => {\n  let y = !!o;\n  r(!ke(n) || !ke(t), $t(e, 'either source or clock'));\n  let b = 0;\n  ke(n) ? b = 1 : E(n) || (n = p(n)), ke(t) ? t = n : (xe(t, e, 'clock'), Array.isArray(t) && (t = w(t))), b && (n = t), s || l || (l = n.shortName);\n  let v = 'none';\n  (g || a) && (E(a) ? v = 'unit' : (r(ve(a), '`filter` should be function or unit'), v = 'fn')), o ? (xe(o, e, 'target'), Ce(e, o)) : 'none' === v && m && L(n) && L(t) ? o = d(i ? i(_e(ee(n)), _e(ee(t))) : _e(ee(n)), {\n    name: l,\n    sid: h,\n    or: s\n  }) : (o = c({\n    name: l,\n    derived: 1,\n    or: s\n  }), u('sampleTarget', X(o)));\n  let k = Pe(),\n      S = [];\n\n  if ('unit' === v) {\n    let [r, n] = At(a, o, t, k, e);\n    S = [...Mt(n), ...Mt(r)];\n  }\n\n  let [x, C] = At(n, o, t, k, e);\n  return he(n, [pt(t, o, [u('sampleSourceLoader'), qe({\n    from: _,\n    target: k\n  }), ...Mt(C), Fe(x, 1, f), ...S, Fe(k), 'fn' === v && De((e, t, _ref26) => {\n    let {\n      a: r\n    } = _ref26;\n    return a(e, r);\n  }, 1), i && De($e), u('sampleSourceUpward', y)], e, i)]), o;\n};\n\nconst Mt = e => [Fe(e), Oe((e, t, _ref27) => {\n  let {\n    a: r\n  } = _ref27;\n  return r;\n}, 1)],\n      At = (e, t, r, n, o) => {\n  let i = L(e),\n      l = i ? ee(e) : Pe(),\n      s = Pe(i);\n  return i || a({\n    parent: e,\n    node: [qe({\n      from: _,\n      target: l\n    }), qe({\n      from: \"value\",\n      store: 1,\n      target: s\n    })],\n    family: {\n      owners: [e, t, r],\n      links: t\n    },\n    meta: {\n      op: o\n    },\n    regional: 1\n  }), u('sampleSource', s, l, n), [l, s];\n},\n      It = (e, t, r, n) => {\n  let a = e[t];\n  a && o({\n    target: a,\n    params: Array.isArray(a) ? a.map(() => r) : r,\n    defer: 1,\n    stack: n\n  });\n},\n      qt = \"22.3.0\";\n\nexport { M as allSettled, y as attach, ct as clearNode, p as combine, b as createApi, v as createDomain, h as createEffect, c as createEvent, a as createNode, d as createStore, m as createStoreObject, F as createWatch, q as fork, mt as forward, k as fromObservable, C as guard, N as hydrate, U as is, o as launch, w as merge, $ as restore, x as sample, z as scopeBind, O as serialize, l as setStoreName, j as split, Re as step, qt as version, ge as withFactory, n as withRegion };","map":{"version":3,"sources":["effector/collection.ts","effector/throw.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/config.ts","effector/template.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/attach.ts","effector/createApi.ts","effector/createDomain.ts","effector/fromObservable.ts","effector/merge.ts","effector/sample.ts","effector/guard.ts","effector/restore.ts","effector/split.ts","effector/fork/allSettled.ts","effector/fork/util.ts","effector/fork/fork.ts","effector/fork/createScope.ts","effector/fork/hydrate.ts","effector/fork/scopeBind.ts","effector/fork/serialize.ts","effector/createWatch.ts","effector/observable.ts","effector/validate.ts","effector/getter.ts","effector/id.ts","effector/own.ts","effector/is.ts","effector/caller.ts","effector/step.ts","effector/stateRef.ts","effector/clearNode.ts","effector/subscription.ts","effector/forward.ts","effector/watch.ts"],"names":["forIn","obj","cb","key","includes","list","item","removeItem","pos","indexOf","splice","add","push","forEach","fn","assert","condition","message","Error","deprecate","subject","suggestion","console","error","regionStack","readTemplate","template","readSidRoot","sid","sidRoot","withRegion","unit","parent","value","getMeta","getParent","withFactory","name","loc","method","createNode","meta","arrifyNodes","Array","isArray","flat","map","getGraph","node","from","source","to","target","child","scope","family","familyRaw","type","regional","sources","links","owners","seq","result","id","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","MAP","STACK","heap","merge","a","b","ret","v","getPriority","r","l","queue","ix","first","last","size","deleteMin","i","pushFirstHeapItem","page","pushHeap","idx","stack","priority","bucket","t","barriers","Set","isRoot","isWatch","isPure","currentPage","forkPage","setForkPage","newForkPage","setCurrentPage","newPage","getPageForRef","reg","getPageRef","ref","isGetState","pageForRef","initRefInScope","launch","payload","upsert","pageForLaunch","stackForLaunch","forkPageForLaunch","params","defer","getForkPage","length","lastStartedState","stop","skip","kernelLoop","hasPageReg","hasScopeReg","local","fail","stepn","step","order","barrierID","fullID","has","delete","data","store","softRead","undefined","readRef","current","pure","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","warnSerializeNode","additionalLinks","sourceRef","isKernelCall","refsMap","sidValuesMap","sidIdMap","before","isFresh","needToAssign","noInit","cmd","field","err","unitObjectName","objOrArr","comma","is","getCompositeName","fullName","toString","setStoreName","rawName","shortName","Object","assign","createName","path","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","metadata","or","childConfig","and","unwrappedNestedValue","isObject","nested","flattenConfig","part","config","isVoid","applyTemplate","handlers","applyParentHook","hookType","hooks","initUnit","kind","configA","configB","isDomain","nextUnitID","named","compositeName","op","unitId","serialize","derived","defaultConfig","thru","getType","subscribe","observer","watch","isFunction","upd","observableSymbol","nativeTemplate","createEvent","deriveEvent","event","mapped","createLinkNode","oldPage","create","nameOrConfig","maybeConfig","graphite","watchUnit","userFnCall","callStack","filterMap","calc","prepend","contramapped","createStore","defaultState","props","plainState","createStateRef","updates","plainStateId","subscribers","Map","stateRef","getState","targetRef","reachedPage","setState","state","reset","units","on","nodeSet","assertNodeSet","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","lastResult","storeState","innerStore","linkNode","callStackAReg","addRefOp","getStoreState","eventOrFn","subscription","updateFilter","_","read","mov","ignored","setMeta","caller","storeRef","reader","combine","handler","stores","rawHandler","slice","structStoreShape","shapeReady","noArraySpread","storeCombination","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","c","batch","childRef","defaultShape","createStoreObject","createDefer","req","Promise","rs","rj","catch","createEffect","instance","use","runner","getCurrent","anyway","finally","done","status","doneData","failData","handlerId","scope_","handler_","onResolve","onSettled","onReject","ok","runFn","then","fx","savedFork","inFlight","x","pending","amount","sidechain","run","attach","injected","effect","mapParams","attached","runnerSteps","runnerFnStep","sourceData","isEffectHandler","computedParams","parentDomain","createApi","setters","createDomain","history","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","acc","res","ownerSet","hook","fromObservable","observable","observableItem","disposer","complete","sampleConfigFields","fieldErrorMessage","validateSampleConfig","atLeastOneFieldExists","sample","clock","batched","greedy","createSampling","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","assertTarget","clockState","filterNodes","filterRef","hasFilter","syncSourceState","readAndFilter","hasSource","src","isSourceStore","guard","restore","domain","launchCase","scopeTargets","split","METHOD","targets","match","configForm","cases","matchIsUnit","matchIsFunction","matchIsShape","__","values","caseNames","keys","splitterSeq","compute","String","lastValues","needBarrier","storeOrFn","updater","caseName","splitterNode","allSettled","start","ctx","reject","parentFork","defers","launchUnits","launchParams","traverseStores","root","visit","normalizeValues","assertEach","fork","domainOrConfig","optiionalConfig","createScope","valuesSidMap","forkInFlightCounter","fxID","resolve","storeStack","storeNode","warnSerialize","resultScope","cloneOf","hydrate","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","traverseTarget","scopeBind","savedForkPage","ignoredStores","ignore","onlyChanges","createWatch","scopeLinks","clearNode","callback","unsubscribe","Symbol","graph","val","idCount","nextStepID","ownerUnit","_link","assertNodeSetItem","valueName","reason","targetField","nextBarrierID","isEffect","toStack","samplerPriority","isFilter","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","events","effects","domains","scopeFn","forward","opts"],"mappings":"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","sourcesContent":["export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value\n  template\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]}\n  meta?: {[name: string]}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value\n  a\n  b\n  c?\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  scope?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?, upsert?: boolean): void\nexport function launch(unit, payload?, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem(\n          'child',\n          page,\n          nextNode,\n          stack,\n          finalValue,\n          getForkPage(stack),\n        )\n      })\n      const forkPage = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = scope.sidValuesMap[sid]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args): [any[], any | void]\nexport function processArgsToConfig(\n  args,\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part, config = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport type {Store, Event, CommonUnit, Effect} from './unit.h'\n\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport type {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\nimport type {Template} from '../forest/index.h'\n\nexport const applyParentHook = (\n  source,\n  target,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind, unit, configA, configB?) => {\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const config = flattenConfig({\n    or: configB,\n    and: typeof configA === 'string' ? {name: configA} : configA,\n  })\n  const {parent = null, sid = null, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : upd => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event, op: string, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName}  *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?,\n  maybeConfig?,\n): Event<Payload> {\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  return Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, nameOrConfig, maybeConfig),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('*  ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName}  *`,\n        derived: true,\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return eventOrFn.watch(payload => fn(store.getState(), payload))\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const derived = getMeta(store, 'derived')\n  const ignored = getMeta(store, 'serialize') === 'ignore'\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (!ignored) setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = list => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj,\n  config?: Config,\n  fn?: (upd) => any,\n) => {\n  const clone = isArray ? list => list.slice() : obj => ({...obj})\n  const defaultState = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value) => any\n  rj: (value) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value) => any\n    rj: (value) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import type {Unit} from './index.h'\nimport type {Effect} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add} from './collection'\n\nexport function createEffect<Payload, Done, Fail = Error>(\n  nameOrConfig,\n  maybeConfig?,\n): Effect<Payload, Done, Fail> {\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  ) as unknown as Effect<Payload, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        ({params, req, handler, args = [params]}, _, stack) => {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd = getParent(stack)\n          ? {params, req: {rs(data) {}, rj(data) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    // @ts-expect-error\n    serialize: 'ignore',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data) => void,\n  args,\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params,\n    req: {\n      rs(_)\n      rj(_)\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  data =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      page: stack.page,\n      scope: getForkPage(stack),\n    })\n\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const rj = onSettled(params, req, false, anyway, stack)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {rs: onSettled(params, req, true, anyway, stack), rj},\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    //@ts-expect-error\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\n\nexport function createDomain(nameOrConfig, maybeConfig?): Domain {\n  const node = createNode({family: {type: DOMAIN}, regional: true})\n\n  const result = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  }\n\n  node.meta = initUnit(DOMAIN, result, nameOrConfig, maybeConfig)\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase()\n\n      const trigger = createNamedEvent(`on${tag}`)\n      result.hooks[lowerCaseTag] = trigger\n\n      const acc = new Set<any>()\n      result.history[`${lowerCaseTag}s`] = acc\n\n      trigger.create = res => {\n        launch(trigger, res)\n        return res\n      }\n      add(\n        getGraph(trigger).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      trigger.watch(data => {\n        own(result, [data])\n        acc.add(data)\n        if (!data.ownerSet) data.ownerSet = acc\n        if (!getParent(data)) data.parent = result\n      })\n      own(result, [trigger])\n\n      result[`onCreate${tag}`] = (hook: (data) => any) => {\n        forEach(acc, hook)\n        return trigger.watch(hook)\n      }\n      result[`create${tag}`] = result[lowerCaseTag] = (\n        nameOrConfig,\n        config?: Config,\n      ) => trigger(factory(nameOrConfig, {parent: result, or: config}))\n    },\n  )\n\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  own(source, [\n    createLinkNode(\n      clock,\n      target,\n      [\n        applyTemplate('sampleSourceLoader'),\n        mov({from: STACK, target: clockState}),\n        ...readAndFilter(hasSource),\n        read(sourceRef, true, batched),\n        ...filterNodes,\n        read(clockState),\n        filterType === 'fn' &&\n          userFnCall((src, _, {a}) => filter(src, a), true),\n        fn && userFnCall(callStackAReg),\n        applyTemplate('sampleSourceUpward', isUpward),\n      ],\n      method,\n      fn,\n    ),\n  ])\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj, defaultState, config?) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch, Stack} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({derived: true, and: metadata})\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope, Event, Effect, DataCarrier} from '../unit.h'\n\nexport function allSettled<T>(\n  start: Event<T> | Effect<T, any, any>,\n  {scope, params: ctx}: {scope: Scope; params?: unknown},\n) {\n  if (!is.unit(start))\n    return Promise.reject(new Error('first argument should be unit'))\n  if (!is.effect(start) && !is.event(start) && !is.store(start))\n    return Promise.reject(new Error('first argument accepts only effects, events and stores'))\n  const defer = createDefer()\n  //@ts-expect-error\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits: DataCarrier[] = [start]\n  const launchParams = [] as Array<{params: unknown; req: unknown} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value: unknown) {\n              //@ts-expect-error\n              defer.value = {status: 'done', value}\n            },\n            rj(value: unknown) {\n              //@ts-expect-error\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key, value) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(values, (value, key) => {\n      assert(is.unit(key), 'Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return values\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?; handlers?},\n  optiionalConfig?: {values?; handlers?},\n) {\n  let config: {values?; handlers?} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (_, scope) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            (getParent(storeStack) &&\n              getMeta(getParent(storeStack).node, 'op') !== 'combine')\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n          }\n        }\n      }),\n    ],\n  })\n  const warnSerializeNode = createNode({\n    node: [\n      calc((_, __, stack) => {\n        const forkPage = getForkPage(stack)\n        if (forkPage) {\n          const storeStack = getParent(stack)\n          if (storeStack) {\n            const storeNode = storeStack.node\n            if (\n              !getMeta(storeNode, 'isCombine') ||\n              (getParent(storeStack) &&\n                getMeta(getParent(storeStack).node, 'op') !== 'combine')\n            ) {\n              forkPage.warnSerialize = true\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange, warnSerializeNode],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n    warnSerializeNode,\n  }\n  return resultScope\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit, {scope}: {scope?: Scope} = {}) {\n  assert(\n    scope || forkPage,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? params => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : params => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  if (scope.warnSerialize) {\n    console.error(\n      'There is a store without sid in this scope, its value is omitted',\n    )\n  }\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Node, Subscription, Unit} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n}: {\n  unit: Unit<T>\n  fn: (value: T) => any\n  scope?: Scope\n}): Subscription {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (unit as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return createSubscription(() => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [unit],\n      family: {owners: unit},\n    })\n    return createSubscription(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction createSubscription(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = obj => (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => obj => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value) => value is Store<unknown>\nexport const event = is(EVENT) as (value) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value) => value is Domain\nexport const scope = is(SCOPE) as (value) => value is Scope\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = stack => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = unit => unit.parent\nexport const getForkPage = (val): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport {getMeta} from './getter'\n\nexport const isObject = value => typeof value === 'object' && value !== null\nexport const isFunction = value => typeof value === 'function'\n\nexport const isVoid = value => value === undefined\n\nexport const assertObject = value =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value,\n  method: string,\n  valueName: string,\n  reason: string,\n) =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (value, method: string, valueName: string) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag, Stack} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = (\n  type: 'compute' | 'mov',\n  data,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = ({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data, scope: {[key: string]}, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data, scope: {[key: string]}, stack: Stack)\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({fn}: {fn(data, scope: {[key: string]}, stack: Stack)}) =>\n  compute({fn, priority: EFFECT})\n\nexport const calc = (\n  fn: (data, scope: {[key: string]}, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data, scope: {[key: string]}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"]},"metadata":{},"sourceType":"module"}